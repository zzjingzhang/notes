# 工程化基础

## Node.js是什么

官方对Node.js 的定义

Node.js是一个基于V8 JavaScript引擎的JavaScript运行时环境

也就是说Node.js基于V8引擎来执行JavaScript的代码，但是不仅仅只有V8引擎

### windows安装nvm

1.在GitHub上有提供对应的window版本：https://github.com/coreybutler/nvm-windows

2.下载nvm-setup.exe并安装

#### nvm常用命令

1.nvm version  -- 查看nvm的版本

2.nvm install x.x.x  --安装指定node版本  nvm install latest 安装最新的版本

3.nvm list  -- 查看已经安装的node版本

4.nvm use x.x.x  --切换版本  **切换的时候 ，windows电脑如果出现乱码，需要用管理员权限打开cmd**

#### 安装n(仅支持mac电脑)

```js
npm install -g n  // 安装工具n
n --version // 查看安装的版本

n  lst  // 安装最新的lts版本
n latest // 安装最新的版本

```

### node程序传递参数

正常情况下执行一个node程序，直接跟上我们的对应的文件即可

```js
node  index.js
```

但是在某些情况下执行node程序的过程中，我们可能希望给node传递一些参数

```js
node -index.js env=development
```

如果我们这样来使用程序，意味着需要在程序中获取到传递的参数

获取参数其实是在process的内置对象中的

如果直接打印这个对象内置对象，它里面包含特别的信息的比较多

如果要拿到这些参数，我们需要通过argv属性，process.argv  它是一个数组，里面包含了我们需要的参数

```powershell
 argv: [
    'C:\\Program Files\\nodejs\\node.exe',
    'C:\\Users\\10244\\Desktop\\前端\\newCode\\04工程化基础\\index',
    'dev=development'
  ],
```

#### 为什么叫argv呢？

在C/C++程序中的main函数中，实际上可以获取到两个参数

argc:argument counter 的缩写，传递参数的个数

argv:argument vector(向量、矢量)的缩写，传入的具体参数

vector 翻译过来是矢量的意思，在程序汇总表示的是一种数据结构

在c++、java中都有这种数据结构，是一种数组结构

在JavaScript中也是一个数组，里面存储一些参数信息

我们可以在代码中，将这些参数遍历出来

```js
process.argv.forEach(item=>{
    console.log(item)
})
```

### node全局对象

#### 特殊的全局对象

为什么称之为特殊的全局对象呢？

这些全局对象实际上市模块中的变量，只是每个模块都有，看来像是全局变量

在命令行交互中不可使用

包括`__dirname`、`__filename`、exports、module、require()

```js
//  __dirname当前文件所在的目录结构  不包括后面的文件名
 console.log(__dirname, '---')
// __filename  当前目录+文件名  包括后面的文件名称
 console.log(__filename, 'filename')
```

#### 常见的全局对象

process对象:process提供了Node进程中相关的信息:

比如Node的运行环境、参数信息等

console对象：提供了简单的调试控制台

定时器函数：在node中使用定时器有好几种方式

```js
// 4.定时器方法
setTimeout(() => {
    console.log('settimeout')
}, 100);
setInterval(() => {
    console.log('setInterval')
}, 50000);


// Immediate: 立即/立刻
// 立即执行
setImmediate(() => {
    console.log("setImmediate")
})


// 额外执行函数
// 添加到下一次tick队列中
process.nextTick(() => {
    console.log('nexttick')
})

```

#### global对象

global是一个全局对象，事实上我们提到的process、console、setTimeout等都是被放到global中的

在新的标准中还有一个globalThis。也是指向全局对象的  globalThis === global  

#### global和window的区别

在浏览器中，全局变量都是在window上的，比如document、setInterval、setTimeout、console等等

但是在浏览器中执行js代码，如果我们在顶级范围内通过var定义一个属性，默认会被添加到window对象上

但是在node中，我们通过var定义一个变量，不会放到全局中

### 模块化

#### 什么是模块化、模块化开发呢？

- 事实上模块化的最终目的是将程序划分为一个个小的结构
- 这个结构中编写属于自己的逻辑代码，有自己的作用域，定义变量名词不会影响其他的结构
- 这个结构可以将自己希望暴露的变量、函数、对象等导出给其他结构使用
- 也 可以通过某种方式，导入另外结构中的变量、函数、对象等

上面说到的结构，就是模块，按照这种结构划分开发程序的过程，就是模块化开发的过程

#### CommonJS规范和Node关系

CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且但是被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时也会简称CJS

- Node是CJS在服务器端一个具有代表性的实现
- Browserify是CJS在浏览器中的一种实现
- webpack打包工具具备对CJS的支持和转换

所以，Node中对CJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发

- 在Node中，每一个js文件都是一个单独的模块
- 这个模块中包括CJS规范的核心变量：exports、module.exports、require
- 我们可以使用这些变量来方便的进行模块化开发

模块化的核心功能：模块本身可以到处暴露的属性，模块又可以导入自己需要的属性

模块化的核心是导出和导入，这个Node对其进行了实现

- exports和module.exports可以负责对模块中的内容进行导出
- require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容

模块化案例

```js
// util.js  导出
const UTIL_NAME = 'util'
function add() {
    console.log('add')
    return 'add1'
}

function sub() {
    console.log('sub')
    return 'sub1'
}
exports.UTIL_NAME = UTIL_NAME
exports.add = add
exports.sub = sub

// main.js 导入
const { UTIL_NAME, add, sub } = require('./util')
console.log(UTIL_NAME)
console.log(add())
console.log(sub())
```

#### require查找规则

导入格式如下：require(x)

情况一：x是一个Node核心模块，比如path、http

直接返回核心模块，并且停止查找

情况二：x是以./或../或(根目录)开头的

第一步：将x当做一个文件在对应的目录下查找：

1.如果有后缀名，按照后缀名的格式查找对应的文件

2.如果没有后缀名，会按照如下顺序：

​       1.直接查找文件x

​        2.查找x.js文件

​        3.查找x.json文件

​        4.查找x.node文件

第二步：没有找到对应的文件，将x作为一个目录

查找目录下面的index文件

​      1.查找x/index.js文件

​      2.查找x/index.json文件

​      3.查找x/index.node文件

如果没有找到，那么报错：not found

情况三：直接是一个x(没有路径)，并且x不是一个核心模块

如果在所有的/node_modules中都没有找到，那么报错：not found

#### 模块的加载过程

结论一：模块在被第一次引入时，模块中的js代码会被运行一次

结论二：模块被多次引入时，会缓存，最终只加载(运行)一次

​    因为每个模块对象module都有一个属性：loaded；为false表示还没加载，为true表示已经加载

结论三：如果有循环引入，Node采用的是深度优先算法