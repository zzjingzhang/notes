#### v8执行的细节

v8引擎的解析图（官方）

<img src="C:\Users\10244\Desktop\前端\notes\02JavaScript\images\22 v8引擎的解析图官方.png" style="zoom:60%;" />

JavaScript源码是如果被解析（parse过程）的呢

1. blink将源码交给v8引擎，stream获取到源码并且进行编码转换

2. scanner会进行词法分析（lexical analysis），词法分析会将代码转换成tokens

3. 接下来tokens会被转换成ast树，经过parser和PreParser：

   ​          Parse就是直接将token转成AST树结构

   ​          PreParser称之为预解析，为什么需要预解析呢？

   ​               这是因为并不是所有的JavaScript代码，在一开始时就会被执行。那么对所有的JavaScript代码进行解析，必然会影响网页的运行效率

   ​              所以v8引起就实现了Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行进行预解析，也就是只解析暂时需   要的内容，而对函数的全量解析是在函数被调用时才会进行

   ​             比如我们在一个函数outer内部定义了另外一个函数inner，那么inner函数就会进行预解析

```js
var name = 'why'
var num1 = 20
var num2 = 30
var result = num1 + num2
```

上面代码的执行过程：

<img src="C:\Users\10244\Desktop\前端\notes\02JavaScript\images2\02全局代码执行过程.png" style="zoom:60%;" />

1.代码被解析，v8引擎内部会帮我们创建一个对象（GlobalObject==>go）

2.运行代码

   2.1 v8为了执行代码，v8引擎内部会有一个执行上下文栈（Execution Content Stack）（函数调用栈）

   2.2 因为我们执行的是全局代码，为了全局代码能够正常执行，需要创建 全局执行上下文（Global Execution Content）（全局代码被执行时才会创建）



初始化全局对象

js引擎会在执行代码前，会在堆内存中创建一个 全局对象：Global Object （GO）

该对象所有的作用域（scope）都可以访问

里面包含Date、Array、String、Number、setTimeout、setinterval等

其中还有一个window属性指向自己

<img src="C:\Users\10244\Desktop\前端\notes\02JavaScript\images2\01堆内存.png" style="zoom:60%;" />

#### js的内存管理

js会在定义变量时为我们分配内存

js对于基本数据类型内存的分配会在执行时，直接在栈空间进行分配

js对于复杂数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用

#### js的垃圾回收

因为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间

在手动管理内存的语言中，我们需要通过一些方式来释放不再需要的内存，比如free函数

但是这种管理方式其实非常低效，影响编写逻辑代码的效率

并且e这种方式对开发者的要求也很高，并且一不小心就会产生内存泄露

所以大部分现代的编程语言都有自己的垃圾回收机制

垃圾回收的英文是Garbage Collection 简称GC

对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放更多的内存空间

而我们语言运行环境，比如java的运行环境jvm，js的运行环境js引擎都会内置垃圾回收器

垃圾回收器我们也会简称为GC，所以在很多地方看到的GC其实指的是垃圾回收器

但是这里又出现了一个很关键的问题：GC怎么知道哪些对象是不再使用的呢？

这里就要用到GC算法了

GC算法  

1.引用计数 弊端：循环引用

2.标记清除



#### 闭包

##### 在计算机科学中对闭包的定义（维基百科）

闭包（closure），又称词法闭包（lexical closure）或函数闭包（function closure）

是在支持头等函数的编程语言中，实现词法绑定的一种技术

闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）

闭包跟函数最大的区别在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行

##### js中的闭包

（MDN的解释）

一个函数和对其周围状态（lexical environment，词法环境）的引用绑定在一起（或者说函数被引用包围），这样的组合就是闭包（closure）

也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域

在js中，每当创建一个函数，闭包就会在函数创建的同时被创建出来



个人理解：

一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包

从广义角度来说，js的函数都是闭包

从狭义角度来说：js中的一个函数，如果访问了外层作用域的变量，那么它就是一个闭包



#### 理解js纯函数

函数式编程中有一个非常重要的概念叫纯函数，js符合函数式编程，所以也有纯函数的概念

在react开发中，纯函数是被多次提及的

比如react中组件就被要求像是一个纯函数（为什么是像，因为还有class组件），redux中有一个reducer的概念，也是必须是一个纯函数

所以掌握纯函数对于理解很多框架的设计是非常有帮助的

##### 纯函数的维基百科定义

在程序设计中，若一个函数符合以下条件，那么这个函数被称之为纯函数

此函数在相同的输入值时，需产生相同的输出

函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关

该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等



对维基百科的总结

确定的输入，一定产生确定的输出

函数在执行过程中，不能产生副作用



副作用

在计算机科学中，也引用了副作用的概念，表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响，比如修改了全局变量，修改参数或者改变外部的存储



slice是纯函数

splice不是纯函数。splice会修改原数组



```js
// 例子
function foo(num1,num2){
    return num1 + num2
}
// foo是纯函数 
// 1.相同的输入一定产生相同的输出
// 2.在执行的过程中不会产生任何副作用

var name = 'abc'
function bar(){
    name = 'cba'
}
// bar 不是纯函数
// 在执行的过程中修改了外部变量

function baz(info){
    info.age = 100
}
var obj = {name:'obj',age:18}
baz(obj)
// baz 不是纯函数
// 在执行的过程中修改了传入的参数
```

##### 纯函数的优势

为什么纯函数在函数式编程中非常重要呢

因为你可以安心的编写和安心的使用

你在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改

你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出





#### 科里化

科里化也书属于函数时编程里面的一个非常重要的概念

维基百科的解释

在计算机科学中，科里化(currying),又翻译为卡瑞化或加里化

是把接收多个参数的函数，变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数，而且返回结果的新函数的技术

科里化声称“如果你固定某些参数，你将得到一个接受余下参数的一个函数”



对维基百科的总结

只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数

这个过程称之为科里化



让函数的职责单一

为什么需要科里化

在函数式编程中，我们其实往往希望一个函数处理的问题尽可能的单一，而不是将一大堆的处理过程交给一个函数来处理

##### 自动科里化的实现

```javascript
  function autoCurry (fn) {
      function curried (...args) {
        // 判断当前已经接收的参数个数，和函数本身需要接收的参数是否已经已经一致了
        // 1.当已经传入的参数 大于或等于 需要的参数，就执行函数
        if (fn.length === args.length) {
          return fn.apply(this, args)
        } else {
          // 2.没有达到需要的参数个数时，需要返回一个新的函数，继续来接收参数
          function curried2 (...args2) {
            const allArgs = [...args, ...args2]
            // 3。接收到参数后，需要递归调用curried来检查函数的个数是否已经达到
            return curried.apply(this, allArgs)

          }
          return curried2
        }
        return curried

      }
    }
```

#### 理解组合函数

组合（compose）函数是在js开发过程中一种对函数的使用技巧，模式

比如我们现在需要对某一个数据进行函数调用，执行两个函数fn1和fn2，这两个函数是依次执行的

那么如果我们每次都需要进行两个函数的调用，操作上就会显得重复

那么是否可以将这两个函数组合起来，自动依次调用呢

这个过程就是对函数的组合，我们称之为组合函数（compose function）

```js
    function myCompose (...fns) {
      const length = fns.length
      for (let i = 0; i < length; i++) {
        if (typeof fns[i] !== 'function') {
          throw new TypeError('Expected arguments are function')
        }
      }

      function compose (...args) {
        let index = 0
        let result = length ? fns[index].apply(this, args) : args
        while (++index < length) {
          result = fns[index].call(this, result)
        }
        return result
      }
      return compose
    }
```

#### with语句

with语句 扩展一个语句的作用域链

```js
  var message = 'wmsg'
    // with语句会形成自己的作用域
    var obj = {
      name: 'obj',
      message: 'omsg'
    }
    function foo () {
      function bar () {
        console.log(message)  // 打印的是全局的message
        with (obj) {
          console.log(message)  // 打印的是obj里面的message
        }
      }
      bar()
    }
    foo()
```



不建议使用with语句，因为它可能是混淆错误和兼容性的根源

#### eval函数

eval函数是一个特殊的函数，它可以将传入的字符串当做js代码来运行

```js
var jsString = ' var message = "hello";console.log(message);'
eval(jsString)
```

不建议在开发中使用eval

eval代码的可读性非常差（代码的可读性是高质量代码的重要原则）

eval是一个字符串，那么有可能在执行的过程中被刻意篡改，那么可能会造成被工具的风险

eval的执行必须经过js解释器，不能被js引擎优化



#### 严格模式

在ES5标准中，js提出了严格模式的概念（strict mode）

严格模式是一种具有限制性的js模式，从而使代码隐式的脱离了“懒散模式”

支持严格模式的浏览器在检测代码中有严格模式时，会以更加严格的方式对代码进行检测和执行

严格模式对正常的js语义进行了一些限制

严格模式通过抛出错误来消除一些原有的静默错误

严格模式让js引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）

严格模式禁用了在ECMAScript为了版本中可能会定义的一些语法





不允许使用原先的八进制格式，例如0123  可以改为0o123

不允许使用with语句

eval函数不会向上引用变量了

严格模式下的this

在严格模式下，自执行函数会指向undefined



#### 对象

对属性操作的控制

前面我们的属性都是直接定义在对象内部，或者直接添加到对象内部的

但是这样来做的时候我们就不能对这个属性进行一些限制：比如这个属性是否可以通过delete删除，这个属性是否在for...in遍历的时候被遍历出来呢

我们想要对一个属性进行进行比较精准的操作控制，那么我们就可以使用属性描述符

通过属性描述符可以精准的添加或修改对象的属性

属性描述符需要使用Object.defineProperty来对属性进行添加或者修改

##### Object.defineProperty

Object.defineProperty()方法会直接在一个对象上定义一个新的属性，或者修改一个对象的现有属性，并返回此对象

```js
Object.defineProperty(obj,prop,descriptor)
```

可以接收三个参数

- obj要定义属性的对象
- prop要定义或修改的属性名称或symbol
- descriptior要定义或修改的属性描述符

返回值

- 被传递给函数的对象

###### 属性描述符的分类

属性描述符的类型有两种

数据属性：（Data Properties）描述符（descriptor）

存取属性：（accessor访问器 Properties）描述符（descriptor）

|            | configurable | enumerate | value  | writable | get    | set    |
| ---------- | ------------ | --------- | ------ | -------- | ------ | ------ |
| 数据描述符 | 可以         | 可以      | 可以   | 可以     | 不可以 | 不可以 |
| 存取描述符 | 可以         | 可以      | 不可以 | 不可以   | 可以   | 可以   |

数据属性描述符

数据属性描述符有如下四个特性

[[Configurable]]:表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性藐视符

   当我们直接在一个对象上定义某个属性时，这个属性的[[Configurable]]为true

   当我们通过属性描述符定义一个属性时，这个属性的[[Configurable]]默认为false

[[Enumerable]]：表示属性是否课堂通过for-in或者Object.keys()返回该属性

​    当我们直接在一个对象上定义某个属性时，这个属性的[[Enumerable]]为true

​    当我们通过属性描述符定义一个属性时，这个属性的[[Enumerable]]默认为false

[[Writable]]：表示是否可以修改属性的值

​      当我们直接在一个对象上定义某个属性时，这个属性的[[Writable]]为true

​      当我们通过属性描述符定义一个属性时，这个属性的[[Writable]]默认为false

[[Value]]：属性的value值，读取属性时会返回该值，修改属性时，会对其进行修改

  默认情况下这个值是undefined

####    认识构造函数

工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型

  但是从某些角度来说，这些对象应该有一个他们共同的类型

构造函数：

构造函数也称之为构造器（constructor），通常是我们创建对象时会调用的函数

在其他面向编程语言里面，构造函数是存在于类中的一个方法，称之为构造方法

但是js中的构造函数有点不太一样

js中的构造函数是怎么样的？

构造函数也是一个普通的函数，从表现形式来说，和千千万万个普通的函数没有任何区别

那么如果这么一个普通函数被使用new操作符来调用了，那么这个函数就称之为是一个构造函数

##### new操作符调用的作用

如果一个函数被使用new操作符调用了，那么它会执行如下操作：

1.在内存中创建一个新的对象（空对象）

2.这个对象内部的[[prototype]]（隐式原型）属性会被赋值为该构造函数的prototype属性

3.构造函数内部的this，会指向创建出来的新对象

4.执行函数的内部代码（函数体代码）

5.如果构造函数没有返回非空对象，则返回创建出来的新对象

原型



